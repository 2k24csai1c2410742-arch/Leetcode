#include <vector>
#include <iostream>
#include <algorithm> // Not strictly necessary for this logic, but useful for general C++

class Solution {
public:
    /**
     * @brief Finds the smallest character in a sorted array that is lexicographically 
     * greater than the target character. If no such character exists (due to wrap-around), 
     * it returns the first character.
     * * @param letters The sorted array of characters.
     * @param target The character to search against.
     * @return The smallest character greater than target, or letters[0] if wrap-around occurs.
     * * The algorithm uses Binary Search for O(log n) time complexity.
     */
    char nextGreatestLetter(std::vector<char>& letters, char target) {
        int n = letters.size();
        int left = 0;
        int right = n - 1;

        // Standard Binary Search to find the first element > target
        while (left <= right) {
            int mid = left + (right - left) / 2;

            if (letters[mid] > target) {
                // letters[mid] is a possible answer. We try to find a smaller 
                // one in the left half, so we update the potential range.
                right = mid - 1;
            } else {
                // letters[mid] <= target. The answer must be strictly greater, 
                // so we discard this element and everything to its left.
                left = mid + 1;
            }
        }

        // After the loop, 'left' points to the index of the first element 
        // strictly greater than 'target' (the ceiling).
        
        // If 'left' is equal to n (the size of the array), it means all elements 
        // were less than or equal to 'target' (the wrap-around case).
        // The modulus operation handles this gracefully:
        // Case 1: Target is small (e.g., 'a' in ["c", "f", "j"]). 'left' = 0. Index = 0 % 3 = 0.
        // Case 2: Target is in the middle (e.g., 'c' in ["c", "f", "j"]). 'left' = 1. Index = 1 % 3 = 1.
        // Case 3: Target is large (e.g., 'z' in ["c", "f", "j"]). 'left' = 3. Index = 3 % 3 = 0.
        return letters[left % n];
    }
};

// Example usage and testing
/*
int main() {
    Solution s;

    std::vector<char> letters1 = {'c', 'f', 'j'};
    std::cout << "Target 'a': Result '" << s.nextGreatestLetter(letters1, 'a') << "' (Expected: 'c')" << std::endl; 

    std::vector<char> letters2 = {'c', 'f', 'j'};
    std::cout << "Target 'c': Result '" << s.nextGreatestLetter(letters2, 'c') << "' (Expected: 'f')" << std::endl; 

    std::vector<char> letters3 = {'x', 'x', 'y', 'y'};
    std::cout << "Target 'z': Result '" << s.nextGreatestLetter(letters3, 'z') << "' (Expected: 'x')" << std::endl; 
    
    std::vector<char> letters4 = {'g', 'j', 'k'};
    std::cout << "Target 'h': Result '" << s.nextGreatestLetter(letters4, 'h') << "' (Expected: 'j')" << std::endl; 

    return 0;
}
*/
