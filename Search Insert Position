#include <vector>
#include <iostream>

class Solution {
public:
    /**
     * @brief Finds the index of the target in a sorted array, or the index 
     * where it would be inserted to maintain order.
     * @param nums The sorted array of distinct integers.
     * @param target The value to search for or find the insertion point of.
     * @return The index of the target, or the insertion index.
     * * The algorithm uses Binary Search, guaranteeing an O(log n) runtime complexity.
     * When the loop terminates (left > right), 'left' always points to the 
     * first element greater than or equal to the target, which is the correct 
     * insertion index.
     */
    int searchInsert(std::vector<int>& nums, int target) {
        // Initialize pointers for the start and end of the search range.
        int left = 0;
        int right = nums.size() - 1;

        // Perform Binary Search
        while (left <= right) {
            // Calculate the middle index using a method to prevent potential integer overflow
            int mid = left + (right - left) / 2;

            if (nums[mid] == target) {
                // Case 1: Target found, return the index.
                return mid;
            } else if (nums[mid] < target) {
                // Case 2: Target is in the right half.
                // Move 'left' to the element immediately after 'mid'.
                left = mid + 1;
            } else {
                // Case 3: nums[mid] > target. Target is in the left half, or 'mid' is the insertion point.
                // Move 'right' to the element immediately before 'mid'.
                right = mid - 1;
            }
        }

        // If the loop completes, the target was not found.
        // 'left' now represents the correct insertion point: 
        // the index of the first element that is larger than the target.
        // If the target is larger than all elements, 'left' will be nums.size().
        return left;
    }
};

// Example usage and testing (optional, but good practice)
/*
int main() {
    Solution s;
    std::vector<int> nums = {1, 3, 5, 6};

    // Example 1: Found
    std::cout << "Target 5: Index " << s.searchInsert(nums, 5) << " (Expected: 2)" << std::endl; 

    // Example 2: Insert in middle
    std::cout << "Target 2: Index " << s.searchInsert(nums, 2) << " (Expected: 1)" << std::endl; 

    // Example 3: Insert at end
    std::cout << "Target 7: Index " << s.searchInsert(nums, 7) << " (Expected: 4)" << std::endl; 

    // Example 4: Insert at beginning
    std::cout << "Target 0: Index " << s.searchInsert(nums, 0) << " (Expected: 0)" << std::endl; 

    return 0;
}
*/
