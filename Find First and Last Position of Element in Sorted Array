#include <vector>
#include <iostream>
#include <algorithm>

class Solution {
private:
    /**
     * @brief Helper function to find either the first or the last index of the target.
     * @param nums The sorted input array.
     * @param target The value to search for.
     * @param findFirst A boolean flag: true for finding the first (left) bound, false for the last (right) bound.
     * @return The index of the first or last occurrence of the target, or -1 if not found.
     */
    int findBound(const std::vector<int>& nums, int target, bool findFirst) {
        int n = nums.size();
        int left = 0;
        int right = n - 1;
        int bound = -1; // Stores the potential index found

        while (left <= right) {
            int mid = left + (right - left) / 2;

            if (nums[mid] == target) {
                // We found an occurrence. Record it.
                bound = mid; 
                
                if (findFirst) {
                    // If looking for the first occurrence, try to find an even earlier one on the left.
                    right = mid - 1;
                } else {
                    // If looking for the last occurrence, try to find an even later one on the right.
                    left = mid + 1;
                }
            } else if (nums[mid] < target) {
                // Target must be on the right.
                left = mid + 1;
            } else {
                // nums[mid] > target, target must be on the left.
                right = mid - 1;
            }
        }
        return bound;
    }

public:
    /**
     * @brief Finds the starting and ending position of a given target value in a sorted array.
     * @param nums The sorted input array.
     * @param target The value to search for.
     * @return A vector of two integers: [start_index, end_index], or [-1, -1] if not found.
     * * The algorithm runs in O(log n) time complexity.
     */
    std::vector<int> searchRange(std::vector<int>& nums, int target) {
        if (nums.empty()) {
            return {-1, -1};
        }

        // 1. Find the starting position (first occurrence)
        int start = findBound(nums, target, true);

        // If the starting position is -1, the target is not in the array, so we can stop.
        if (start == -1) {
            return {-1, -1};
        }

        // 2. Find the ending position (last occurrence)
        int end = findBound(nums, target, false);

        // Return the collected range
        return {start, end};
    }
};

// Example usage and testing
/*
int main() {
    Solution s;
    std::vector<int> nums1 = {5, 7, 7, 8, 8, 10};
    int target1 = 8;
    std::vector<int> result1 = s.searchRange(nums1, target1);
    std::cout << "Input: [5,7,7,8,8,10], Target: 8 -> Output: [" << result1[0] << ", " << result1[1] << "] (Expected: [3, 4])" << std::endl; 

    std::vector<int> nums2 = {5, 7, 7, 8, 8, 10};
    int target2 = 6;
    std::vector<int> result2 = s.searchRange(nums2, target2);
    std::cout << "Input: [5,7,7,8,8,10], Target: 6 -> Output: [" << result2[0] << ", " << result2[1] << "] (Expected: [-1, -1])" << std::endl; 

    std::vector<int> nums3 = {};
    int target3 = 0;
    std::vector<int> result3 = s.searchRange(nums3, target3);
    std::cout << "Input: [], Target: 0 -> Output: [" << result3[0] << ", " << result3[1] << "] (Expected: [-1, -1])" << std::endl; 

    std::vector<int> nums4 = {1, 1, 1, 1, 1};
    int target4 = 1;
    std::vector<int> result4 = s.searchRange(nums4, target4);
    std::cout << "Input: [1,1,1,1,1], Target: 1 -> Output: [" << result4[0] << ", " << result4[1] << "] (Expected: [0, 4])" << std::endl; 

    return 0;
}
*/
